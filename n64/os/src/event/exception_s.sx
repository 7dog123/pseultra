/*
 * pseultra/n64/os/src/event/exception_s.sx
 * Exception handler
 * 
 * (C) pseudophpt 2018 
 */

#include <os_priv.sx>

.global __osHandlerStart
.global __osHandlerEnd
.global __osHandleException
.global __osUnmaskInterrupts
.global __osEnableInterrupts
.global __osDisableInterrupts
.global __osHandleTimerInterrupt

.macro savereg

lui $k0, %hi(__osExceptionRegSave)
addiu $k0, %lo(__osExceptionRegSave)

.irp reg,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
sw $\reg, (\reg * 4)($k0)
.endr

.endm

.macro loadreg

lui $k0, %hi(__osExceptionRegSave)
addiu $k0, %lo(__osExceptionRegSave)

.irp reg,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
lw $\reg, (\reg * 4)($k0)
.endr

.endm

//
// Unmasks all interrupts
//

__osUnmaskInterrupts:
mfc0 $k0, Status

// MIPS Interrupts

ori $k0, 0xff00 // Unmask all interrupts

or $k0, $k1 
mtc0 $k0, Status

jr $ra // Return

//
// Enable all interrupts
//

__osEnableInterrupts:
mfc0 $k0, Status

ori $k0, 0x0001
mtc0 $k0, Status

jr $ra

//
// Disable all interrupts
//

__osDisableInterrupts:
mfc0 $k0, Status

li $k1, ~0x1
and $k0, $k1
mtc0 $k0, Status

jr $ra

//
// Handles timer interrupts
//

__osHandleTimerInterrupt:

// Clear ip7 bit
mfc0 $k0, Cause
li $k1, ~N64_COP0_CAUSE_IP7
and $k0, $k1
mtc0 $k0, Cause 

jr $ra

//
// Called on exception 
//

__osHandlerStart:

lui $k0, %hi(__osHandleException)
addiu $k0, %lo(__osHandleException)
jr $k0

__osHandlerEnd:

//
// Called on exception by initial vector
//

__osHandleException:

savereg

mfc0 $t0, Cause
andi $t1, $t0, N64_COP0_CAUSE_EXC_CODE // Get exception code

bne $t1, N64_COP0_CAUSE_EXC_CODE_INT, .handleException // Branch to handle exception if it's not the interrupt code 

.handleInterrupt:

andi $a0, $t0, N64_COP0_CAUSE_IP // Pass interrupt bits
jal __osHandleInterrupt
b .done

.handleException:

.done:

loadreg

eret

.lcomm __osExceptionRegSave, 32 * 4
