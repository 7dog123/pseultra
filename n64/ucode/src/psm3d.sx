/*
 * pseultra/n64/boot/ucode/psm3d.sx
 * PSM3D microcode - Pseultra Microcode 3D
 * 
 * (C) pseudophpt 2018
 */

/*
 * NOTES ON THE STATUS WORD
 *
 * The PSM3D microcode, and any other microcodes for use with the pseultra lib-
 * rary, assume the last word of DMEM, 0xFFC, to be zero-initialized on first
 * run, and is used as a status word. In this microcode, the byte at 0xFFC is
 * used to specify whether the XBUS buffer has been initialized or not, so
 * that more tasks can be run while the RDP output produced by previous tasks
 * are processed by the RDP
 */

// TODO: add notes on stack

// N64 Definitions
#include <n64.sx>
#include <mips.sx>
#include <ucode.sx>

#define PSM3D_XBUS_BUFFER_SIZE 0x400

#define PSM3D_STATUS_WORD 0xFFC // Location of the status word in SP DMEM
#define PSM3D_STATUS_XBUS_INIT_BYTE (PSM3D_STATUS_WORD + 0) // Has the XBUS buffer been initialized?

#define PSM3D_RDP_THROUGH_CMD 0x80

#define op_ret b .ExecutionLoop

.global uPSM3DTextStart
.global uPSM3DTextEnd
.global uPSM3DDataStart
.global uPSM3DDataEnd

//
// Beginning of task execution
//
// At this point, the microcode assumes the header is stored in DMEM
//
.align 3 // Align to 64-bit boundaries
.section .text

uPSM3DTextStart:

//
// Test if the XBUS buffer has been initialized 
//

#define xbus_initialized $t0

.XBUSTestInit:
    lb xbus_initialized, PSM3D_STATUS_XBUS_INIT_BYTE($zero)
    bnez xbus_initialized, .BeginExecution

//
// Initialize the XBUS buffer
//

// TODO: If CMD_CUR == CMD_END, we can reset them both to 0 to prevent the need to do a FiFo wrap-around

.XBUSInit:

#define set_xbus_dmem_dma $t0

    ori set_xbus_dmem_dma, $zero, 0x2 // Use XBUS as a command buffer 
    mtc0 set_xbus_dmem_dma, CMD_STATUS

#undef set_xbus_dmem_dma

#define xbus_buffer_start $t0

    ori xbus_buffer_start, $zero, xbus_buffer // Initialize command buffer positions
    mtc0 xbus_buffer_start, CMD_START // CMD_START is written to first, since CMD_END begins actual processing
    mtc0 xbus_buffer_start, CMD_END

#undef xbus_buffer_start

    ori $t0, $zero, 1 // Store 1 to XBUS initialized byte to signify that it has been initialized
    sb $t0, PSM3D_STATUS_XBUS_INIT_BYTE($zero)

#undef xbus_initialized

//
// Begin execution
//

#define dl_dram_ptr $s0

.BeginExecution:
    lw dl_dram_ptr, header($zero) // Initialize pointer to the current DRAM location

//
// Main execution loop
//

// TODO: Load more than 1 command at a time

.ExecutionLoop:
    move $a0, dl_dram_ptr // Load display list command
    ori $a1, $zero, cmd
    ori $a2, $zero, 8

    jal DMARead // DMA command

    addiu dl_dram_ptr, 8 // Advance display list counter

#define dl_cmd $t0
#define dl_cmd_handler $t1

    lb dl_cmd, cmd($zero) // Get display list command

#define dl_cmd_type $t2

    andi dl_cmd_type, dl_cmd, PSM3D_RDP_THROUGH_CMD // Check if it's an RDP throughput command
    beqz dl_cmd_type, .NormalCommand

#undef dl_cmd_type

#define cmd_ptr $a0
#define cmd_len $a1

    ori cmd_ptr, $zero, cmd // Push command
    ori cmd_len, $zero, 8

    jal XBUSPush

    op_ret // Back to normal loop

#undef cmd_len
#undef cmd_ptr

.NormalCommand:

    addu dl_cmd, dl_cmd // Shift left 2
    addu dl_cmd, dl_cmd 

    lw dl_cmd_handler, jump_tbl(dl_cmd) // Get address of handler

    jr dl_cmd_handler // Jump to handler

#undef dl_cmd_handler
#undef dl_cmd

#undef dl_dram_ptr

//
// Finish execution with a break instruction
//

.FinishExecution:
    break

#include "dma.sx"
#include "xbus.sx"

#include "psm3d/noop.sx"
#include "psm3d/enddl.sx"

uPSM3DTextEnd:

//
// BSS
//

.section .bss

.align 3

// XBUS buffer
.lcomm xbus_buffer, PSM3D_XBUS_BUFFER_SIZE
// Current display list command
.lcomm cmd, 0x8

//
// Data
//

.section .data

uPSM3DDataStart:

// 0x10 bytes of header written to by the task executor
header: .dword 0, 0
// Jump table

.align 1

jump_tbl:
.word OPNoop 
.word OPEndDL

uPSM3DDataEnd:
