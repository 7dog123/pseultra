/*
 * pseultra/n64/ucode/src/psm3d/tri.sx
 * PSM3D microcode Tri functions
 * 
 * (C) pseudophpt 2018
 */

//////////////////////////////////////////////////////////////////////////////
//                                                                          // 
// Tri                                                                      // 
//                                                                          // 
// Draws a triangle primitive                                               // 
//                                                                          // 
// FORMAT:                                                                  // 
//                                                                          // 
// 07 XX YY ZZ -- -- -- --                                                  // 
//                                                                          // 
// X: First vertex index                                                    // 
// Y: Second vertex index                                                   // 
// Z: Third vertex index                                                    // 
//                                                                          // 
//////////////////////////////////////////////////////////////////////////////

.global OPTri

// TODO: Culling
// TODO: Separate tri coefficient calculations in diff files

// There has to be a way to improve this, it's so fucking long.
// Maybe improve sorting code, then perform the calculation cyclically?

OPTri:
    // Load vertices and perform culling. ORs and ANDs all clip flags. If the 
    // X or Y or Z AND results are 1, cull. If Z OR results are 1, cull.

    lb r16, (%lo(cmd) + 1)($zero) // Get vertex cache offset
    sll r16, 4 
    lh r17, (%lo(vtx_cache) + 2)(r16) // Get y coordinate
    lb r20, (%lo(vtx_cache) + 9)(r16) // Get clip flags
    or r21, r20, r0 // Duplicate for OR

        ldv vc16, 0, vtx_cache, r16 // Load vertex

    lb r16, (%lo(cmd) + 2)($zero) // Get vertex cache offset
    sll r16, 4 
    lh r18, (%lo(vtx_cache) + 2)(r16) // Get y coordinate
    lb r22, (%lo(vtx_cache) + 9)(r16) // Get clip flags
    and r20, r22 // Perform OR and AND
    or r21, r22

        ldv vc18, 0, vtx_cache, r16 // Load vertex

    lb r16, (%lo(cmd) + 3)($zero) // Get vertex cache offset
    sll r16, 4 
    lh r19, (%lo(vtx_cache) + 2)(r16) // Get y coordinate
    lb r22, (%lo(vtx_cache) + 9)(r16) // Get clip flags
    and r20, r22 // Perform OR and AND
    or r21, r22

        ldv vc20, 0, vtx_cache, r16 // Load vertex

    bnez r20, .Cull // Cull if all vertices are outside clip bounds
    andi r21, 0x04 // Only care about Z for OR
    bnez r21, .Cull // Cull if any vertex outside Z clip bounds
    
    ori r21, $zero, 0x08 // Triangle command
    ori r22, $zero, %lo(cmd) // Command pointer
    b .NoCull
    ori r23, $zero, 0x20 // Command length

.Cull:
    op_ret // Return if triangle culled
    nop

.NoCull:
    bge r19, r17, .NoSwapXZ // if (x > z) swap(x, z)
    nop

        vor vc22, nullconst, vc16, f // Swap X and Z
    
    or r20, $zero, r17 // disgosten

        vor vc16, nullconst, vc20, f 
        
    or r17, $zero, r19
    
        vor vc20, nullconst, vc22, f 

    or r19, $zero, r20

.NoSwapXZ:

    bge r18, r17, .NoSwapXY // if (x > y) swap(x, y)
    nop
    
        vor vc22, nullconst, vc16, f // Swap X and Y

    or r20, $zero, r17

        vor vc16, nullconst, vc18, f 
        
    or r17, $zero, r18
    
        vor vc18, nullconst, vc22, f 

    or r18, $zero, r20

.NoSwapXY:
    
    bge r19, r18, .NoSwapYZ // if (y > z) swap(y, z)
    nop
    
        vor vc22, nullconst, vc20, f // Swap Y and Z

    or r20, $zero, r18

        vor vc20, nullconst, vc18, f 
        
    or r18, $zero, r19

        vor vc18, nullconst, vc22, f 

    or r19, $zero, r20

.NoSwapYZ:
        vor vc17, nullconst, nullconst, f // Make fractional registers
        vor vc19, nullconst, nullconst, f
        vor vc21, nullconst, nullconst, f

        vmov vc17, 2, vc16, e3 // Load z frac
        vmov vc19, 2, vc18, e3 
        vmov vc21, 2, vc20, e3 
        
        ssv vc18, 0, cmd + 0x8, $zero // Store XL, int
        ssv nullconst, 0, cmd + 0xa, $zero // Store XL, frac
        
        ssv vc16, 0, cmd + 0x10, $zero // Store XH, int
        ssv nullconst, 0, cmd + 0x12, $zero // Store XH, frac
        
        ssv vc16, 0, cmd + 0x18, $zero // Store XM, int
        ssv nullconst, 0, cmd + 0x1a, $zero // Store XM, frac

        vsub vc22, vc20, vc18, f
        
    jal CalcTriDxDy // Calculate DxLDy
    nop

        ssv vc26, 0, cmd + 0xc, $zero // Store int
        ssv vc27, 0, cmd + 0xe, $zero // Store frac

        vsub vc22, vc20, vc16, f

    jal CalcTriDxDy // Calculate DxHDy
    nop

        ssv vc26, 0, cmd + 0x14, $zero // Store int
        ssv vc27, 0, cmd + 0x16, $zero // Store frac

        vsub vc22, vc18, vc16, f
        
    jal CalcTriDxDy // Calculate DxMDy
    nop

        ssv vc26, 0, cmd + 0x1c, $zero // Store int
        ssv vc27, 0, cmd + 0x1e, $zero // Store frac

        // TODO: Make it 1 operation

        vmov vc26, 0, vc16, e1 // Load Y coordinates into one vector
        vmov vc26, 1, vc18, e1 
        vmov vc26, 2, vc20, e1 

        vmudh vc26, vc26, v2nconst, v2n_4

        vadd vc27, nullconst, v2nconst2, v2n2_16384 // vc27 = 0x3FFF
        vsub vc27, vc27, v2nconst, v2n_1

        vand vc26, vc26, vc27, f // Mask y coords

        ssv vc26, 0, cmd + 0x6, $zero // Store y coords
        ssv vc26, 2, cmd + 0x4, $zero
        ssv vc26, 4, cmd + 0x2, $zero

    andi r24, rsp_mode, PSM3D_MODE_ZBUF
    beq r24, r0, .NoZBuffer
    addiu r22, 0x20 // Add to command pointer     

.ZBuffer: // Make sure to check if z buffering is enabled in the RSP options
    ori r21, 0x1 // Z-Buffering command

    addiu r23, 0x10 // Command size

        ssv vc16, 4, 0, r22 // Store depth
        ssv vc17, 4, 2, r22 
        
        vsubc vc23, vc17, vc21, f // Calculate v3-v1
        vsub vc22, vc16, vc20, f
        
        vrcph vc24, 1, vc22, 1 // Get 1/(y3-y1) 
        vrcpl vc25, 1, vc23, 1
        vrcph vc24, 1, nullconst, 0
        
        vmudn vc25, vc25, v2nconst, v2n_2 // Shift left 1 for correct point position 
        vmadh vc24, vc24, v2nconst, v2n_2        
        vmadn vc25, nullconst, nullconst, f 
        
        vmudl vc26, vc23, vc25, e1 // Calculate DzDe = (z3-z1)/(y3-y1)
        vmadm vc26, vc22, vc25, e1
        vmadn vc27, vc23, vc24, e1
        vmadh vc26, vc22, vc24, e1
        
        ssv vc26, 4, 8, r22 // Store DzDe
        ssv vc27, 4, 10, r22 // Store DzDe, frac

        vsubc vc25, vc19, vc17, f // Calculate v2-v1
        vsub vc24, vc18, vc16, f

        vor vc27, nullconst, nullconst, f // Clear vc27, vc29
        vor vc29, nullconst, nullconst, f
        
        // The z-buffer code has to calculate dz/dx and dz/dy. This is done by
        // performing a cross product of the two edges (v2-v1) and (v3-v1) to
        // obtain a normal vector <a, b, c>, converting that to a plane 
        // equation, and then taking the partial derivatives -a/c and -b/c 
        // respectively.

        vmov vc26, 0, vc22, e1 // Load cross product coefficients
        vmov vc26, 1, vc22, e2
        vmov vc27, 1, vc23, e2
        vmov vc26, 2, vc22, e2
        vmov vc27, 2, vc23, e2
        vmov vc26, 3, vc22, e0
        vmov vc26, 4, vc22, e0
        vmov vc26, 5, vc22, e1

        vmov vc28, 0, vc24, e2
        vmov vc29, 0, vc25, e2
        vmov vc28, 1, vc24, e1
        vmov vc28, 2, vc24, e0
        vmov vc28, 3, vc24, e2
        vmov vc29, 3, vc25, e2
        vmov vc28, 4, vc24, e1
        vmov vc28, 5, vc24, e0

        vmudl vc24, vc27, vc29, f // Calculate cross product (v2-v1) x (v3-v1)
        vmadm vc24, vc26, vc29, f
        vmadn vc25, vc27, vc28, f
        vmadh vc24, vc26, vc28, f

        vsubc vc23, vc25, vc25, q0
        vsub vc22, vc24, vc24, q0

        vrcph vc22, 5, vc22, 5 // Calculate 1/c
        vrcpl vc23, 5, vc23, 5
        vrcph vc22, 5, nullconst, f

        vmudn vc25, vc23, v2nconst, v2n_2 // Shift left 1 for correct point position 
        vmadh vc24, vc22, v2nconst, v2n_2        
        vmadn vc25, nullconst, nullconst, f 

        vmudl vc26, vc23, vc25, e5 // Calculate a/c, b/c 
        vmadm vc26, vc22, vc25, e5
        vmadn vc27, vc23, vc24, e5
        vmadh vc26, vc22, vc24, e5

        vsubc vc25, nullconst, vc27, f // Calculate -a/c, -b/c (dz/dx, dz/dy)
        vsub vc24, nullconst, vc26, f

        ssv vc24, 2, 4, r22 // Store DzDx
        ssv vc25, 2, 6, r22 // Store DzDx, frac
        
        ssv vc24, 6, 12, r22 // Store DzDy
        ssv vc25, 6, 14, r22 // Store DzDy, frac

.NoZBuffer:
        lw r17, (%lo(cmd) + 0x14)($zero) // Load DxHDy
        lw r18, (%lo(cmd) + 0x1c)($zero) // Load DxMDy

        bge r17, r18, .LeftMajor 
        ori r16, $zero, 0

.RightMajor:
    ori r16, $zero, 0x80

.LeftMajor:
    sb r16, (%lo(cmd) + 1)($zero)

    sb r21, (%lo(cmd))($zero) // Store triangle command
   
    ori r24, $zero, %lo(cmd) // Push command
    jal XBUSPush
    move r25, r23 // Get length

    op_ret // Return operation
    nop

// Little subroutine to calculate Dx/Dy

CalcTriDxDy:
        vrcph vc24, 1, vc22, 1
        vrcpl vc25, 1, nullconst, 1 // Calculate 1 / dy (dx stays in this register)
        vrcph vc24, 1, nullconst, 0 

        vmudn vc29, vc25, v2nconst, v2n_2 // Shift left 1 for correct point position 
        vmadh vc28, vc24, v2nconst, v2n_2        
        vmadn vc29, nullconst, nullconst, f 

        vmudm vc26, vc22, vc29, h1 // Calculate DxLDy
        vmadh vc26, vc22, vc28, h1 
        vmadn vc27, nullconst, nullconst, f

    jr $ra
    nop
