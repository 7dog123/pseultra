/*
 * pseultra/n64/ucode/src/psm3d/loadvtx.sx
 * PSM3D microcode LoadVtx function
 * 
 * (C) pseudophpt 2018
 */

//////////////////////////////////////////////////////////////////////////////
//                                                                          // 
// LoadVtx                                                                  // 
//                                                                          // 
// Loads a vertex into the vertex cache                                     // 
//                                                                          // 
////////////////////////////////////////////////////////////////////////////// 
//                                                                          // 
// FORMAT:                                                                  // 
//                                                                          // 
// 05 -- PP CC -- DD DD DD                                                  // 
//                                                                          // 
// P: Position in vertex cache to load                                      // 
// C: Count of vertices to load                                             // 
// D: DRAM address of vertices                                              // 
//                                                                          // 
//////////////////////////////////////////////////////////////////////////////

// Stored vertex format:
// X, Y, Zi, Zf, F, GB, S, T
// F: Flags
// RRRRRRRR --xyzXYZ 
// x: outside of negative x clip space
// y: outside of negative y clip space
// z: outside of negative z clip space
// X: outside of positive x clip space
// Y: outside of positive y clip space
// Z: outside of positive z clip space
// R: Red shading color
// GB: Green and blue shading colors

// TODO: Pre-multiply projection and model matrices
// TODO: Two vertices at a time

.global OPLoadVtx

OPLoadVtx:

    lb r16, (%lo(cmd) + 3)($zero) // Load count
    lb r17, (%lo(cmd) + 2)($zero) // Load position
    sll r17, 4
    addiu r17, %lo(vtx_cache)
    lw r18, (%lo(cmd) + 4)($zero) // Load DRAM address
    
.VertexLoop:

    move r24, r18 // Load from DRAM address
    ori r25, $zero, %lo(cmd) // Load into command 
    jal DMARead 
    ori r26, $zero, 31 // Read vertex

    lw r24, (%lo(cmd) + 16)($zero) // Load s and t
    sw r24, 12(r17)

    andi r24, rsp_mode, PSM3D_MODE_LIGHT
    beq r24, r0, .NoLight
    nop
    
.Light:

    // Initialize combined light as ambient
    ori r24, r0, ambient_light

        ldv vc16, 0, 0, r24

        vnop 0, 0, 0, 0

    // Final calculated light in vc16 
        
        sdv vc16, 0, 32, cmd_addr // Store RGB values
        lh r19, (%lo(cmd) + 34)($zero) // Load G value
        sll r19, 8 // Shift 8 left
        lh r20, (%lo(cmd) + 36)($zero) // Load B value
        or r19, r20 // Combine)
        lh r20, (%lo(cmd) + 32)($zero) // Load R value
        sll r20, 8 // Shift 8 left

    b .CalcCoordinates
    nop

.NoLight:

    lh r19, (%lo(cmd) + 14)($zero) // Load G and B shading coeffs as colors
    lh r20, (%lo(cmd) + 6)($zero) // Load R shading coeff as color 

// After this step, r27 and r28 will contain the shading color of the vertex
.CalcCoordinates:

        ldv vc8, 0, cmd, $zero // Load integral part into vc8
        ldv vc8, 8, cmd, $zero

        vmov vc8, 3, v2nconst, e0 // Load 1 into w coordinate
        vmov vc8, 7, v2nconst, e0 
        
        ldv vc9, 0, cmd + 8, $zero // Load fractional part into vc9
        ldv vc9, 8, cmd + 8, $zero

        vmov vc9, 3, nullconst, e0 // Load 0 into w coordinate fractopm
        vmov vc9, 7, nullconst, e0
    
    move r24, mtx_stack_ptr // Model matrix multiply 
    jal MTXApply4x4
    addiu r24, -PSM3D_MTX_SIZE

        vor vc8, nullconst, vc14, f // Use output as input to projection
        vor vc9, nullconst, vc15, f

        sdv vc8, 0, cmd + 32, $zero // Copy second halves
        ldv vc8, 8, cmd + 32, $zero

        sdv vc9, 0, cmd + 32, $zero
        ldv vc9, 8, cmd + 32, $zero
    
    jal MTXApply4x4
    ori r24, $zero, %lo(mtx_proj) // Projection matrix multiply         

        vch vc16, vc14, vc14, h3 // Clip x, y, z against [-w, w] 
        vcl vc16, vc15, vc15, h3
        cfc2 r24, VCC
        
        srl r25, r24, 5 // Compress clip flags into format
        andi r24, 0x07
        andi r25, 0x38
        or r24, r25

        or r20, r24 // OR with calculated red value

        sh r19, 10(r17)
        sh r20, 8(r17) // Save clip flags and red

        vrcph vc18, 3, vc14, 3 // Get 1/w 
        vrcpl vc19, 3, vc15, 3
        vrcph vc18, 3, vc14, 3

        vmudn vc17, vc19, v2nconst, v2n_2 // Shift left 1 for correct 1/w value
        vmadh vc16, vc18, v2nconst, v2n_2
        vmadn vc17, nullconst, nullconst, f

        vmudl vc18, vc15, vc17, h3 // Calculate NDC (Normalized Device Coordinates) by multiplying <x, y, z> by 1/w
        vmadm vc18, vc14, vc17, h3
        vmadn vc19, vc15, vc16, h3
        vmadh vc18, vc14, vc16, h3
      
        vadd vc22, vc18, v2nconst, v2n_1 // Add 1 to z integer part, range is now [0, 2]

        vmudn vc23, vc19, v2nconst2, v2n2_256 // Shift z left 1 byte for max precision with floating point 
        vmadh vc22, vc22, v2nconst2, v2n2_256        
        vmadn vc23, nullconst, nullconst, f 
        
        ssv vc22, 4, 4, r17 // Store (zi, zf) into vertex cache
        ssv vc23, 4, 6, r17
        
        vmudn vc17, vc19, vpsize, f // Calculate device coordinates by apply viewport transformations
        vmadh vc16, vc18, vpsize, f 
        vmadn vc17, nullconst, nullconst, f 

        vmudn vc18, vc17, v2nconst, v2n_2 // Get high bit for rounding
        vmadm vc18, nullconst, nullconst, f

        vadd vc16, vc16, vc18, f // Add rounded bit
        vadd vc16, vc16, vpsize, f
        vadd vc16, vc16, vpoff, f

        slv vc16, 0, 0, r17 // Store (x, y) into vertex cache

    addiu r16, -1 // Decrement count left

    addiu r18, 32
    bne r16, $zero, .VertexLoop // Jump back if we're not done 
    addiu r17, PSM3D_VTX_SIZE

    op_ret
    nop

